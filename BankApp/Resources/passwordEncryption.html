<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    
    
    <script>        
        window.onload = function () {
            var publicKey = document.getElementById("publicKey").value;
            var userPassword = document.getElementById("userNativePassword").value;
            document.getElementById("encryptedPassword").value = versafe.EncryptRSA(userPassword, publicKey);
        }
    </script>

    <script>
        function BigInteger(a, b, c) { if (a != null) if ("number" == typeof a) { this.fromNumber(a, b, c) } else if (b == null && "string" != typeof a) { this.fromString(a, 256) } else { this.fromString(a, b) } } function nbi() { return new BigInteger(null) } function am1(a, b, c, d, e, f) { while (--f >= 0) { var g = b * this[a++] + c[d] + e; e = Math.floor(g / 67108864); c[d++] = g & 67108863 } return e } function am2(a, b, c, d, e, f) { var g = b & 32767, h = b >> 15; while (--f >= 0) { var i = this[a] & 32767; var j = this[a++] >> 15; var k = h * i + j * g; i = g * i + ((k & 32767) << 15) + c[d] + (e & 1073741823); e = (i >>> 30) + (k >>> 15) + h * j + (e >>> 30); c[d++] = i & 1073741823 } return e } function am3(a, b, c, d, e, f) { var g = b & 16383, h = b >> 14; while (--f >= 0) { var i = this[a] & 16383; var j = this[a++] >> 14; var k = h * i + j * g; i = g * i + ((k & 16383) << 14) + c[d] + e; e = (i >> 28) + (k >> 14) + h * j; c[d++] = i & 268435455 } return e } function int2char(a) { return BI_RM.charAt(a) } function intAt(a, b) { var c = BI_RC[a.charCodeAt(b)]; return c == null ? -1 : c } function bnpCopyTo(a) { for (var b = this.t - 1; b >= 0; --b) { a[b] = this[b] } a.t = this.t; a.s = this.s } function bnpFromInt(a) { this.t = 1; this.s = a < 0 ? -1 : 0; if (a > 0) { this[0] = a } else if (a < -1) { this[0] = a + DV } else { this.t = 0 } } function nbv(a) { var b = nbi(); b.fromInt(a); return b } function bnpFromString(a, b) { var c; if (b == 16) { c = 4 } else if (b == 8) { c = 3 } else if (b == 256) { c = 8 } else if (b == 2) { c = 1 } else if (b == 32) { c = 5 } else if (b == 4) { c = 2 } else { this.fromRadix(a, b); return } this.t = 0; this.s = 0; var d = a.length, e = false, f = 0; while (--d >= 0) { var g = c == 8 ? a[d] & 255 : intAt(a, d); if (g < 0) { if (a.charAt(d) == "-") { e = true } continue } e = false; if (f == 0) { this[this.t++] = g } else if (f + c > this.DB) { this[this.t - 1] |= (g & (1 << this.DB - f) - 1) << f; this[this.t++] = g >> this.DB - f } else this[this.t - 1] |= g << f; f += c; if (f >= this.DB) { f -= this.DB } } if (c == 8 && (a[0] & 128) != 0) { this.s = -1; if (f > 0) { this[this.t - 1] |= (1 << this.DB - f) - 1 << f } } this.clamp(); if (e) { BigInteger.ZERO.subTo(this, this) } } function bnpClamp() { var a = this.s & this.DM; while (this.t > 0 && this[this.t - 1] == a) { --this.t } } function bnToString(a) { if (this.s < 0) { return "-" + this.negate().toString(a) } var b; if (a == 16) { b = 4 } else if (a == 8) { b = 3 } else if (a == 2) { b = 1 } else if (a == 32) { b = 5 } else if (a == 4) { b = 2 } else return this.toRadix(a); var c = (1 << b) - 1, d, e = false, f = "", g = this.t; var h = this.DB - g * this.DB % b; if (g-- > 0) { if (h < this.DB && (d = this[g] >> h) > 0) { e = true; f = int2char(d) } while (g >= 0) { if (h < b) { d = (this[g] & (1 << h) - 1) << b - h; d |= this[--g] >> (h += this.DB - b) } else { d = this[g] >> (h -= b) & c; if (h <= 0) { h += this.DB; --g } } if (d > 0) { e = true } if (e) { f += int2char(d) } } } return e ? f : "0" } function bnNegate() { var a = nbi(); BigInteger.ZERO.subTo(this, a); return a } function bnAbs() { return this.s < 0 ? this.negate() : this } function bnCompareTo(a) { var b = this.s - a.s; if (b != 0) { return b } var c = this.t; b = c - a.t; if (b != 0) { return b } while (--c >= 0) { if ((b = this[c] - a[c]) != 0) { return b } } return 0 } function nbits(a) { var b = 1, c; if ((c = a >>> 16) != 0) { a = c; b += 16 } if ((c = a >> 8) != 0) { a = c; b += 8 } if ((c = a >> 4) != 0) { a = c; b += 4 } if ((c = a >> 2) != 0) { a = c; b += 2 } if ((c = a >> 1) != 0) { a = c; b += 1 } return b } function bnBitLength() { if (this.t <= 0) { return 0 } return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM) } function bnpDLShiftTo(a, b) { var c; for (c = this.t - 1; c >= 0; --c) { b[c + a] = this[c] } for (c = a - 1; c >= 0; --c) { b[c] = 0 } b.t = this.t + a; b.s = this.s } function bnpDRShiftTo(a, b) { for (var c = a; c < this.t; ++c) { b[c - a] = this[c] } b.t = Math.max(this.t - a, 0); b.s = this.s } function bnpLShiftTo(a, b) { var c = a % this.DB; var d = this.DB - c; var e = (1 << d) - 1; var f = Math.floor(a / this.DB), g = this.s << c & this.DM, h; for (h = this.t - 1; h >= 0; --h) { b[h + f + 1] = this[h] >> d | g; g = (this[h] & e) << c } for (h = f - 1; h >= 0; --h) { b[h] = 0 } b[f] = g; b.t = this.t + f + 1; b.s = this.s; b.clamp() } function bnpRShiftTo(a, b) { b.s = this.s; var c = Math.floor(a / this.DB); if (c >= this.t) { b.t = 0; return } var d = a % this.DB; var e = this.DB - d; var f = (1 << d) - 1; b[0] = this[c] >> d; for (var g = c + 1; g < this.t; ++g) { b[g - c - 1] |= (this[g] & f) << e; b[g - c] = this[g] >> d } if (d > 0) { b[this.t - c - 1] |= (this.s & f) << e } b.t = this.t - c; b.clamp() } function bnpSubTo(a, b) { var c = 0, d = 0, e = Math.min(a.t, this.t); while (c < e) { d += this[c] - a[c]; b[c++] = d & this.DM; d >>= this.DB } if (a.t < this.t) { d -= a.s; while (c < this.t) { d += this[c]; b[c++] = d & this.DM; d >>= this.DB } d += this.s } else { d += this.s; while (c < a.t) { d -= a[c]; b[c++] = d & this.DM; d >>= this.DB } d -= a.s } b.s = d < 0 ? -1 : 0; if (d < -1) { b[c++] = this.DV + d } else if (d > 0) { b[c++] = d } b.t = c; b.clamp() } function bnpMultiplyTo(a, b) { var c = this.abs(), d = a.abs(); var e = c.t; b.t = e + d.t; while (--e >= 0) { b[e] = 0 } for (e = 0; e < d.t; ++e) { b[e + c.t] = c.am(0, d[e], b, e, 0, c.t) } b.s = 0; b.clamp(); if (this.s != a.s) { BigInteger.ZERO.subTo(b, b) } } function bnpSquareTo(a) { var b = this.abs(); var c = a.t = 2 * b.t; while (--c >= 0) { a[c] = 0 } for (c = 0; c < b.t - 1; ++c) { var d = b.am(c, b[c], a, 2 * c, 0, 1); if ((a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV) { a[c + b.t] -= b.DV; a[c + b.t + 1] = 1 } } if (a.t > 0) { a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1) } a.s = 0; a.clamp() } function bnpDivRemTo(a, b, c) { var d = a.abs(); if (d.t <= 0) { return } var e = this.abs(); if (e.t < d.t) { if (b != null) b.fromInt(0); if (c != null) this.copyTo(c); return } if (c == null) { c = nbi() } var f = nbi(), g = this.s, h = a.s; var i = this.DB - nbits(d[d.t - 1]); if (i > 0) { d.lShiftTo(i, f); e.lShiftTo(i, c) } else { d.copyTo(f); e.copyTo(c) } var j = f.t; var k = f[j - 1]; if (k == 0) { return } var l = k * (1 << this.F1) + (j > 1 ? f[j - 2] >> this.F2 : 0); var m = this.FV / l, n = (1 << this.F1) / l, o = 1 << this.F2; var p = c.t, q = p - j, r = b == null ? nbi() : b; f.dlShiftTo(q, r); if (c.compareTo(r) >= 0) { c[c.t++] = 1; c.subTo(r, c) } BigInteger.ONE.dlShiftTo(j, r); r.subTo(f, f); while (f.t < j) { f[f.t++] = 0 } while (--q >= 0) { var s = c[--p] == k ? this.DM : Math.floor(c[p] * m + (c[p - 1] + o) * n); if ((c[p] += f.am(0, s, c, q, 0, j)) < s) { f.dlShiftTo(q, r); c.subTo(r, c); while (c[p] < --s) { c.subTo(r, c) } } } if (b != null) { c.drShiftTo(j, b); if (g != h) { BigInteger.ZERO.subTo(b, b) } } c.t = j; c.clamp(); if (i > 0) c.rShiftTo(i, c); if (g < 0) { BigInteger.ZERO.subTo(c, c) } } function bnMod(a) { var b = nbi(); this.abs().divRemTo(a, null, b); if (this.s < 0 && b.compareTo(BigInteger.ZERO) > 0) { a.subTo(b, b) } return b } function Classic(a) { this.m = a } function cConvert(a) { if (a.s < 0 || a.compareTo(this.m) >= 0) { return a.mod(this.m) } else return a } function cRevert(a) { return a } function cReduce(a) { a.divRemTo(this.m, null, a) } function cMulTo(a, b, c) { a.multiplyTo(b, c); this.reduce(c) } function cSqrTo(a, b) { a.squareTo(b); this.reduce(b) } function bnpInvDigit() { if (this.t < 1) { return 0 } var a = this[0]; if ((a & 1) == 0) { return 0 } var b = a & 3; b = b * (2 - (a & 15) * b) & 15; b = b * (2 - (a & 255) * b) & 255; b = b * (2 - ((a & 65535) * b & 65535)) & 65535; b = b * (2 - a * b % this.DV) % this.DV; return b > 0 ? this.DV - b : -b } function Montgomery(a) { this.m = a; this.mp = a.invDigit(); this.mpl = this.mp & 32767; this.mph = this.mp >> 15; this.um = (1 << a.DB - 15) - 1; this.mt2 = 2 * a.t } function montConvert(a) { var b = nbi(); a.abs().dlShiftTo(this.m.t, b); b.divRemTo(this.m, null, b); if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) { this.m.subTo(b, b) } return b } function montRevert(a) { var b = nbi(); a.copyTo(b); this.reduce(b); return b } function montReduce(a) { while (a.t <= this.mt2) { a[a.t++] = 0 } for (var b = 0; b < this.m.t; ++b) { var c = a[b] & 32767; var d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM; c = b + this.m.t; a[c] += this.m.am(0, d, a, b, 0, this.m.t); while (a[c] >= a.DV) { a[c] -= a.DV; a[++c]++ } } a.clamp(); a.drShiftTo(this.m.t, a); if (a.compareTo(this.m) >= 0) { a.subTo(this.m, a) } } function montSqrTo(a, b) { a.squareTo(b); this.reduce(b) } function montMulTo(a, b, c) { a.multiplyTo(b, c); this.reduce(c) } function bnpIsEven() { return (this.t > 0 ? this[0] & 1 : this.s) == 0 } function bnpExp(a, b) { if (a > 4294967295 || a < 1) { return BigInteger.ONE } var c = nbi(), d = nbi(), e = b.convert(this), f = nbits(a) - 1; e.copyTo(c); while (--f >= 0) { b.sqrTo(c, d); if ((a & 1 << f) > 0) { b.mulTo(d, e, c) } else { var g = c; c = d; d = g } } return b.revert(c) } function bnModPowInt(a, b) { var c; if (a < 256 || b.isEven()) { c = new Classic(b) } else { c = new Montgomery(b) } return this.exp(a, c) } function parseBigInt(a, b) { return new BigInteger(a, b) } function linebrk(a, b) { var c = ""; var d = 0; while (d + b < a.length) { c += a.substring(d, d + b) + "\n"; d += b } return c + a.substring(d, a.length) } function byte2Hex(a) { if (a < 16) { return "0" + a.toString(16) } else { return a.toString(16) } } function pkcs1pad2(a, b) { var c = new Array; var d = a.length - 1; while (d >= 0 && b > 0) { var e = a.charCodeAt(d--); if (e < 128) { c[--b] = e } else if (e > 127 && e < 2048) { c[--b] = e & 63 | 128; c[--b] = e >> 6 | 192 } else { c[--b] = e & 63 | 128; c[--b] = e >> 6 & 63 | 128; c[--b] = e >> 12 | 224 } } c[--b] = 0; var f = new SecureRandom; var g = new Array; while (b > 2) { g[0] = 0; while (g[0] == 0) { f.nextBytes(g) } c[--b] = g[0] } c[--b] = 2; c[--b] = 0; return new BigInteger(c) } function RSAKey() { this.n = null; this.e = 0; this.d = null; this.p = null; this.q = null; this.dmp1 = null; this.dmq1 = null; this.coeff = null } function RSASetPublic(a, b) { if (a != null && b != null && a.length > 0 && b.length > 0) { this.n = parseBigInt(a, 16); this.e = parseInt(b, 16) } } function RSADoPublic(a) { return a.modPowInt(this.e, this.n) } function RSAEncrypt(a) { var b = pkcs1pad2(a, this.n.bitLength() + 7 >> 3); if (b == null) { return null } var c = this.doPublic(b); if (c == null) { return null } var d = c.toString(16); if ((d.length & 1) == 0) { return d } else { return "0" + d } } function rng_seed_int(a) { rng_pool[rng_pptr++] ^= a & 255; rng_pool[rng_pptr++] ^= a >> 8 & 255; rng_pool[rng_pptr++] ^= a >> 16 & 255; rng_pool[rng_pptr++] ^= a >> 24 & 255; if (rng_pptr >= rng_psize) { rng_pptr -= rng_psize } } function rng_seed_time() { rng_seed_int((new Date).getTime()) } function rng_get_byte() { if (rng_state == null) { rng_seed_time(); rng_state = prng_newstate(); rng_state.init(rng_pool); for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) { rng_pool[rng_pptr] = 0 } rng_pptr = 0 } return rng_state.next() } function rng_get_bytes(a) { var b; for (b = 0; b < a.length; ++b) { a[b] = rng_get_byte() } } function SecureRandom() { } function Arcfour() { this.i = 0; this.j = 0; this.S = new Array } function ARC4init(a) { var b, c, d; for (b = 0; b < 256; ++b) { this.S[b] = b } c = 0; for (b = 0; b < 256; ++b) { c = c + this.S[b] + a[b % a.length] & 255; d = this.S[b]; this.S[b] = this.S[c]; this.S[c] = d } this.i = 0; this.j = 0 } function ARC4next() { var a; this.i = this.i + 1 & 255; this.j = this.j + this.S[this.i] & 255; a = this.S[this.i]; this.S[this.i] = this.S[this.j]; this.S[this.j] = a; return this.S[a + this.S[this.i] & 255] } function prng_newstate() { return new Arcfour } function b64tohex(a) { var b = ""; var c; var d = 0; var e; for (c = 0; c < a.length; ++c) { if (a.charAt(c) == b64pad) { break } v = b64map.indexOf(a.charAt(c)); if (v < 0) { continue } if (d == 0) { b += int2char(v >> 2); e = v & 3; d = 1 } else if (d == 1) { b += int2char(e << 2 | v >> 4); e = v & 15; d = 2 } else if (d == 2) { b += int2char(e); b += int2char(v >> 2); e = v & 3; d = 3 } else { b += int2char(e << 2 | v >> 4); b += int2char(v & 15); d = 0 } } if (d == 1) { b += int2char(e << 2) } return b } function b64toBA(a) { var b = b64tohex(a); var c; var d = new Array; for (c = 0; 2 * c < b.length; ++c) { d[c] = parseInt(b.substring(2 * c, 2 * c + 2), 16) } return d } function jx_additional() { } function bnClone() { var a = nbi(); this.copyTo(a); return a } function bnIntValue() { if (this.s < 0) { if (this.t == 1) return this[0] - this.DV; else if (this.t == 0) return -1 } else if (this.t == 1) return this[0]; else if (this.t == 0) return 0; return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0] } function bnByteValue() { return this.t == 0 ? this.s : this[0] << 24 >> 24 } function bnShortValue() { return this.t == 0 ? this.s : this[0] << 16 >> 16 } function bnpChunkSize(a) { return Math.floor(Math.LN2 * this.DB / Math.log(a)) } function bnSigNum() { if (this.s < 0) return -1; else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0; else return 1 } function bnpToRadix(a) { if (a == null) a = 10; if (this.signum() == 0 || a < 2 || a > 36) return "0"; var b = this.chunkSize(a); var c = Math.pow(a, b); var d = nbv(c), e = nbi(), f = nbi(), g = ""; this.divRemTo(d, e, f); while (e.signum() > 0) { g = (c + f.intValue()).toString(a).substr(1) + g; e.divRemTo(d, e, f) } return f.intValue().toString(a) + g } function bnpFromRadix(a, b) { this.fromInt(0); if (b == null) b = 10; var c = this.chunkSize(b); var d = Math.pow(b, c), e = false, f = 0, g = 0; for (var h = 0; h < a.length; ++h) { var i = intAt(a, h); if (i < 0) { if (a.charAt(h) == "-" && this.signum() == 0) e = true; continue } g = b * g + i; if (++f >= c) { this.dMultiply(d); this.dAddOffset(g, 0); f = 0; g = 0 } } if (f > 0) { this.dMultiply(Math.pow(b, f)); this.dAddOffset(g, 0) } if (e) BigInteger.ZERO.subTo(this, this) } function bnpFromNumber(a, b, c) { if ("number" == typeof b) { if (a < 2) this.fromInt(1); else { this.fromNumber(a, c); if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this); if (this.isEven()) this.dAddOffset(1, 0); while (!this.isProbablePrime(b)) { this.dAddOffset(2, 0); if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this) } } } else { var d = new Array, e = a & 7; d.length = (a >> 3) + 1; b.nextBytes(d); if (e > 0) d[0] &= (1 << e) - 1; else d[0] = 0; this.fromString(d, 256) } } function bnToByteArray() { var a = this.t, b = new Array; b[0] = this.s; var c = this.DB - a * this.DB % 8, d, e = 0; if (a-- > 0) { if (c < this.DB && (d = this[a] >> c) != (this.s & this.DM) >> c) b[e++] = d | this.s << this.DB - c; while (a >= 0) { if (c < 8) { d = (this[a] & (1 << c) - 1) << 8 - c; d |= this[--a] >> (c += this.DB - 8) } else { d = this[a] >> (c -= 8) & 255; if (c <= 0) { c += this.DB; --a } } if ((d & 128) != 0) d |= -256; if (e == 0 && (this.s & 128) != (d & 128))++e; if (e > 0 || d != this.s) b[e++] = d } } return b } function bnEquals(a) { return this.compareTo(a) == 0 } function bnMin(a) { return this.compareTo(a) < 0 ? this : a } function bnMax(a) { return this.compareTo(a) > 0 ? this : a } function bnpBitwiseTo(a, b, c) { var d, e, f = Math.min(a.t, this.t); for (d = 0; d < f; ++d) c[d] = b(this[d], a[d]); if (a.t < this.t) { e = a.s & this.DM; for (d = f; d < this.t; ++d) c[d] = b(this[d], e); c.t = this.t } else { e = this.s & this.DM; for (d = f; d < a.t; ++d) c[d] = b(e, a[d]); c.t = a.t } c.s = b(this.s, a.s); c.clamp() } function op_and(a, b) { return a & b } function bnAnd(a) { var b = nbi(); this.bitwiseTo(a, op_and, b); return b } function op_or(a, b) { return a | b } function bnOr(a) { var b = nbi(); this.bitwiseTo(a, op_or, b); return b } function op_xor(a, b) { return a ^ b } function bnXor(a) { var b = nbi(); this.bitwiseTo(a, op_xor, b); return b } function op_andnot(a, b) { return a & ~b } function bnAndNot(a) { var b = nbi(); this.bitwiseTo(a, op_andnot, b); return b } function bnNot() { var a = nbi(); for (var b = 0; b < this.t; ++b) a[b] = this.DM & ~this[b]; a.t = this.t; a.s = ~this.s; return a } function bnShiftLeft(a) { var b = nbi(); if (a < 0) this.rShiftTo(-a, b); else this.lShiftTo(a, b); return b } function bnShiftRight(a) { var b = nbi(); if (a < 0) this.lShiftTo(-a, b); else this.rShiftTo(a, b); return b } function lbit(a) { if (a == 0) return -1; var b = 0; if ((a & 65535) == 0) { a >>= 16; b += 16 } if ((a & 255) == 0) { a >>= 8; b += 8 } if ((a & 15) == 0) { a >>= 4; b += 4 } if ((a & 3) == 0) { a >>= 2; b += 2 } if ((a & 1) == 0)++b; return b } function bnGetLowestSetBit() { for (var a = 0; a < this.t; ++a) if (this[a] != 0) return a * this.DB + lbit(this[a]); if (this.s < 0) return this.t * this.DB; return -1 } function cbit(a) { var b = 0; while (a != 0) { a &= a - 1; ++b } return b } function bnBitCount() { var a = 0, b = this.s & this.DM; for (var c = 0; c < this.t; ++c) a += cbit(this[c] ^ b); return a } function bnTestBit(a) { var b = Math.floor(a / this.DB); if (b >= this.t) return this.s != 0; return (this[b] & 1 << a % this.DB) != 0 } function bnpChangeBit(a, b) { var c = BigInteger.ONE.shiftLeft(a); this.bitwiseTo(c, b, c); return c } function bnSetBit(a) { return this.changeBit(a, op_or) } function bnClearBit(a) { return this.changeBit(a, op_andnot) } function bnFlipBit(a) { return this.changeBit(a, op_xor) } function bnpAddTo(a, b) { var c = 0, d = 0, e = Math.min(a.t, this.t); while (c < e) { d += this[c] + a[c]; b[c++] = d & this.DM; d >>= this.DB } if (a.t < this.t) { d += a.s; while (c < this.t) { d += this[c]; b[c++] = d & this.DM; d >>= this.DB } d += this.s } else { d += this.s; while (c < a.t) { d += a[c]; b[c++] = d & this.DM; d >>= this.DB } d += a.s } b.s = d < 0 ? -1 : 0; if (d > 0) b[c++] = d; else if (d < -1) b[c++] = this.DV + d; b.t = c; b.clamp() } function bnAdd(a) { var b = nbi(); this.addTo(a, b); return b } function bnSubtract(a) { var b = nbi(); this.subTo(a, b); return b } function bnMultiply(a) { var b = nbi(); this.multiplyTo(a, b); return b } function bnDivide(a) { var b = nbi(); this.divRemTo(a, b, null); return b } function bnRemainder(a) { var b = nbi(); this.divRemTo(a, null, b); return b } function bnDivideAndRemainder(a) { var b = nbi(), c = nbi(); this.divRemTo(a, b, c); return new Array(b, c) } function bnpDMultiply(a) { this[this.t] = this.am(0, a - 1, this, 0, 0, this.t); ++this.t; this.clamp() } function bnpDAddOffset(a, b) { if (a == 0) return; while (this.t <= b) this[this.t++] = 0; this[b] += a; while (this[b] >= this.DV) { this[b] -= this.DV; if (++b >= this.t) this[this.t++] = 0; ++this[b] } } function NullExp() { } function nNop(a) { return a } function nMulTo(a, b, c) { a.multiplyTo(b, c) } function nSqrTo(a, b) { a.squareTo(b) } function bnPow(a) { return this.exp(a, new NullExp) } function bnpMultiplyLowerTo(a, b, c) { var d = Math.min(this.t + a.t, b); c.s = 0; c.t = d; while (d > 0) c[--d] = 0; var e; for (e = c.t - this.t; d < e; ++d) c[d + this.t] = this.am(0, a[d], c, d, 0, this.t); for (e = Math.min(a.t, b) ; d < e; ++d) this.am(0, a[d], c, d, 0, b - d); c.clamp() } function bnpMultiplyUpperTo(a, b, c) { --b; var d = c.t = this.t + a.t - b; c.s = 0; while (--d >= 0) c[d] = 0; for (d = Math.max(b - this.t, 0) ; d < a.t; ++d) c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b); c.clamp(); c.drShiftTo(1, c) } function Barrett(a) { this.r2 = nbi(); this.q3 = nbi(); BigInteger.ONE.dlShiftTo(2 * a.t, this.r2); this.mu = this.r2.divide(a); this.m = a } function barrettConvert(a) { if (a.s < 0 || a.t > 2 * this.m.t) return a.mod(this.m); else if (a.compareTo(this.m) < 0) return a; else { var b = nbi(); a.copyTo(b); this.reduce(b); return b } } function barrettRevert(a) { return a } function barrettReduce(a) { a.drShiftTo(this.m.t - 1, this.r2); if (a.t > this.m.t + 1) { a.t = this.m.t + 1; a.clamp() } this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3); this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); while (a.compareTo(this.r2) < 0) a.dAddOffset(1, this.m.t + 1); a.subTo(this.r2, a); while (a.compareTo(this.m) >= 0) a.subTo(this.m, a) } function barrettSqrTo(a, b) { a.squareTo(b); this.reduce(b) } function barrettMulTo(a, b, c) { a.multiplyTo(b, c); this.reduce(c) } function bnModPow(a, b) { var c = a.bitLength(), d, e = nbv(1), f; if (c <= 0) return e; else if (c < 18) d = 1; else if (c < 48) d = 3; else if (c < 144) d = 4; else if (c < 768) d = 5; else d = 6; if (c < 8) f = new Classic(b); else if (b.isEven()) f = new Barrett(b); else f = new Montgomery(b); var g = new Array, h = 3, i = d - 1, j = (1 << d) - 1; g[1] = f.convert(this); if (d > 1) { var k = nbi(); f.sqrTo(g[1], k); while (h <= j) { g[h] = nbi(); f.mulTo(k, g[h - 2], g[h]); h += 2 } } var l = a.t - 1, m, n = true, o = nbi(), p; c = nbits(a[l]) - 1; while (l >= 0) { if (c >= i) m = a[l] >> c - i & j; else { m = (a[l] & (1 << c + 1) - 1) << i - c; if (l > 0) m |= a[l - 1] >> this.DB + c - i } h = d; while ((m & 1) == 0) { m >>= 1; --h } if ((c -= h) < 0) { c += this.DB; --l } if (n) { g[m].copyTo(e); n = false } else { while (h > 1) { f.sqrTo(e, o); f.sqrTo(o, e); h -= 2 } if (h > 0) f.sqrTo(e, o); else { p = e; e = o; o = p } f.mulTo(o, g[m], e) } while (l >= 0 && (a[l] & 1 << c) == 0) { f.sqrTo(e, o); p = e; e = o; o = p; if (--c < 0) { c = this.DB - 1; --l } } } return f.revert(e) } function bnGCD(a) { var b = this.s < 0 ? this.negate() : this.clone(); var c = a.s < 0 ? a.negate() : a.clone(); if (b.compareTo(c) < 0) { var d = b; b = c; c = d } var e = b.getLowestSetBit(), f = c.getLowestSetBit(); if (f < 0) return b; if (e < f) f = e; if (f > 0) { b.rShiftTo(f, b); c.rShiftTo(f, c) } while (b.signum() > 0) { if ((e = b.getLowestSetBit()) > 0) b.rShiftTo(e, b); if ((e = c.getLowestSetBit()) > 0) c.rShiftTo(e, c); if (b.compareTo(c) >= 0) { b.subTo(c, b); b.rShiftTo(1, b) } else { c.subTo(b, c); c.rShiftTo(1, c) } } if (f > 0) c.lShiftTo(f, c); return c } function bnpModInt(a) { if (a <= 0) return 0; var b = this.DV % a, c = this.s < 0 ? a - 1 : 0; if (this.t > 0) if (b == 0) c = this[0] % a; else for (var d = this.t - 1; d >= 0; --d) c = (b * c + this[d]) % a; return c } function bnModInverse(a) { var b = a.isEven(); if (this.isEven() && b || a.signum() == 0) return BigInteger.ZERO; var c = a.clone(), d = this.clone(); var e = nbv(1), f = nbv(0), g = nbv(0), h = nbv(1); while (c.signum() != 0) { while (c.isEven()) { c.rShiftTo(1, c); if (b) { if (!e.isEven() || !f.isEven()) { e.addTo(this, e); f.subTo(a, f) } e.rShiftTo(1, e) } else if (!f.isEven()) f.subTo(a, f); f.rShiftTo(1, f) } while (d.isEven()) { d.rShiftTo(1, d); if (b) { if (!g.isEven() || !h.isEven()) { g.addTo(this, g); h.subTo(a, h) } g.rShiftTo(1, g) } else if (!h.isEven()) h.subTo(a, h); h.rShiftTo(1, h) } if (c.compareTo(d) >= 0) { c.subTo(d, c); if (b) e.subTo(g, e); f.subTo(h, f) } else { d.subTo(c, d); if (b) g.subTo(e, g); h.subTo(f, h) } } if (d.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO; if (h.compareTo(a) >= 0) return h.subtract(a); if (h.signum() < 0) h.addTo(a, h); else return h; if (h.signum() < 0) return h.add(a); else return h } function bnIsProbablePrime(a) { var b, c = this.abs(); if (c.t == 1 && c[0] <= lowprimes[lowprimes.length - 1]) { for (b = 0; b < lowprimes.length; ++b) if (c[0] == lowprimes[b]) return true; return false } if (c.isEven()) return false; b = 1; while (b < lowprimes.length) { var d = lowprimes[b], e = b + 1; while (e < lowprimes.length && d < lplim) d *= lowprimes[e++]; d = c.modInt(d); while (b < e) if (d % lowprimes[b++] == 0) return false } return c.millerRabin(a) } function bnpMillerRabin(a) { var b = this.subtract(BigInteger.ONE); var c = b.getLowestSetBit(); if (c <= 0) return false; var d = b.shiftRight(c); a = a + 1 >> 1; if (a > lowprimes.length) a = lowprimes.length; var e = nbi(); for (var f = 0; f < a; ++f) { e.fromInt(lowprimes[f]); var g = e.modPow(d, this); if (g.compareTo(BigInteger.ONE) != 0 && g.compareTo(b) != 0) { var h = 1; while (h++ < c && g.compareTo(b) != 0) { g = g.modPowInt(2, this); if (g.compareTo(BigInteger.ONE) == 0) return false } if (g.compareTo(b) != 0) return false } } return true } function pkcs1unpad2(a, b) { var c = a.toByteArray(); var d = 0; while (d < c.length && c[d] == 0)++d; if (c.length - d != b - 1 || c[d] != 2) return null; ++d; while (c[d] != 0) if (++d >= c.length) return null; var e = ""; while (++d < c.length) { var f = c[d] & 255; if (f < 128) { e += String.fromCharCode(f) } else if (f > 191 && f < 224) { e += String.fromCharCode((f & 31) << 6 | c[d + 1] & 63); ++d } else { e += String.fromCharCode((f & 15) << 12 | (c[d + 1] & 63) << 6 | c[d + 2] & 63); d += 2 } } return e } function RSASetPrivate(a, b, c) { if (a != null && b != null && a.length > 0 && b.length > 0) { this.n = parseBigInt(a, 16); this.e = parseInt(b, 16); this.d = parseBigInt(c, 16) } else return false } function RSADoPrivate(a) { if (this.p == null || this.q == null) { return a.modPow(this.d, this.n) } var b = a.mod(this.p).modPow(this.dmp1, this.p); var c = a.mod(this.q).modPow(this.dmq1, this.q); while (b.compareTo(c) < 0) { b = b.add(this.p) } return b.subtract(c).multiply(this.coeff).mod(this.p).multiply(this.q).add(c) } function RSADecrypt(a) { var b = parseBigInt(a, 16); var c = this.doPrivate(b); if (c == null) return null; return pkcs1unpad2(c, this.n.bitLength() + 7 >> 3) } var dbits; var canary = 0xdeadbeefcafe; var j_lm = (canary & 16777215) == 15715070; if (j_lm && navigator.appName == "Microsoft Internet Explorer") { BigInteger.prototype.am = am2; dbits = 30 } else if (j_lm && navigator.appName != "Netscape") { BigInteger.prototype.am = am1; dbits = 26 } else { BigInteger.prototype.am = am3; dbits = 28 } BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = (1 << dbits) - 1; BigInteger.prototype.DV = 1 << dbits; var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP); BigInteger.prototype.F1 = BI_FP - dbits; BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"; var BI_RC = new Array; var rr, vv; rr = "0".charCodeAt(0); for (vv = 0; vv <= 9; ++vv) { BI_RC[rr++] = vv } rr = "a".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } rr = "A".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1); RSAKey.prototype.doPublic = RSADoPublic; RSAKey.prototype.setPublic = RSASetPublic; RSAKey.prototype.encrypt = RSAEncrypt; var rng_state; var rng_pool; var rng_pptr; if (rng_pool == null) { rng_pool = new Array; rng_pptr = 0; var t; if (navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) { var z = window.crypto.random(32); for (t = 0; t < z.length; ++t) { rng_pool[rng_pptr++] = z.charCodeAt(t) & 255 } } while (rng_pptr < rng_psize) { t = Math.floor(65536 * Math.random()); rng_pool[rng_pptr++] = t >>> 8; rng_pool[rng_pptr++] = t & 255 } rng_pptr = 0 } SecureRandom.prototype.nextBytes = rng_get_bytes; Arcfour.prototype.init = ARC4init; Arcfour.prototype.next = ARC4next; var rng_psize = 256; var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var b64pad = "="; var Aes = {}; Aes.Cipher = function (a, b) { var c = 4; var d = b.length / c - 1; var e = [[], [], [], []]; for (var f = 0; f < 16; f++) { e[f % 4][Math.floor(f / 4)] = a[f] } e = Aes.AddRoundKey(e, b, 0, c); for (var g = 1; g < d; g++) { e = Aes.SubBytes(e, c); e = Aes.ShiftRows(e, c); e = Aes.MixColumns(e, c); e = Aes.AddRoundKey(e, b, g, c) } e = Aes.SubBytes(e, c); e = Aes.ShiftRows(e, c); e = Aes.AddRoundKey(e, b, d, c); var h = new Array(16); for (var f = 0; f < 16; f++) { h[f] = e[f % 4][Math.floor(f / 4)] } return h }; Aes.KeyExpansion = function (a) { var b = 4; var c = a.length / 4; var d = c + 6; var e = new Array(b * (d + 1)); var f = new Array(4); for (var g = 0; g < c; g++) { var h = [a[4 * g], a[4 * g + 1], a[4 * g + 2], a[4 * g + 3]]; e[g] = h } for (var g = c; g < b * (d + 1) ; g++) { e[g] = new Array(4); for (var i = 0; i < 4; i++) { f[i] = e[g - 1][i] } if (g % c == 0) { f = Aes.SubWord(Aes.RotWord(f)); for (var i = 0; i < 4; i++) { f[i] ^= Aes.Rcon[g / c][i] } } else if (c > 6 && g % c == 4) { f = Aes.SubWord(f) } for (var i = 0; i < 4; i++) { e[g][i] = e[g - c][i] ^ f[i] } } return e }; Aes.SubBytes = function (a, b) { for (var c = 0; c < 4; c++) { for (var d = 0; d < b; d++) { a[c][d] = Aes.Sbox[a[c][d]] } } return a }; Aes.ShiftRows = function (a, b) { var c = new Array(4); for (var d = 1; d < 4; d++) { for (var e = 0; e < 4; e++) { c[e] = a[d][(e + d) % b] } for (var e = 0; e < 4; e++) { a[d][e] = c[e] } } return a }; Aes.MixColumns = function (a, b) { for (var c = 0; c < 4; c++) { var d = new Array(4); var e = new Array(4); for (var f = 0; f < 4; f++) { d[f] = a[f][c]; e[f] = a[f][c] & 128 ? a[f][c] << 1 ^ 283 : a[f][c] << 1 } a[0][c] = e[0] ^ d[1] ^ e[1] ^ d[2] ^ d[3]; a[1][c] = d[0] ^ e[1] ^ d[2] ^ e[2] ^ d[3]; a[2][c] = d[0] ^ d[1] ^ e[2] ^ d[3] ^ e[3]; a[3][c] = d[0] ^ e[0] ^ d[1] ^ d[2] ^ e[3] } return a }; Aes.AddRoundKey = function (a, b, c, d) { for (var e = 0; e < 4; e++) { for (var f = 0; f < d; f++) { a[e][f] ^= b[c * 4 + f][e] } } return a }; Aes.SubWord = function (a) { for (var b = 0; b < 4; b++) { a[b] = Aes.Sbox[a[b]] } return a }; Aes.RotWord = function (a) { var b = a[0]; for (var c = 0; c < 3; c++) { a[c] = a[c + 1] } a[3] = b; return a }; Aes.Sbox = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]; Aes.Rcon = [[0, 0, 0, 0], [1, 0, 0, 0], [2, 0, 0, 0], [4, 0, 0, 0], [8, 0, 0, 0], [16, 0, 0, 0], [32, 0, 0, 0], [64, 0, 0, 0], [128, 0, 0, 0], [27, 0, 0, 0], [54, 0, 0, 0]]; var AesCtr = {}; AesCtr.encrypt = function (a, b, c) { var d = 16; if (!(c == 128 || c == 192 || c == 256)) { return "" } a = Utf8.encode(a); b = Utf8.encode(b); var e = c / 8; var f = new Array(e); for (var g = 0; g < e; g++) { f[g] = isNaN(b.charCodeAt(g)) ? 0 : b.charCodeAt(g) } var h = Aes.Cipher(f, Aes.KeyExpansion(f)); h = h.concat(h.slice(0, e - 16)); var i = new Array(d); var j = (new Date).getTime(); var k = Math.floor(j / 1e3); var l = j % 1e3; for (var g = 0; g < 4; g++) { i[g] = k >>> g * 8 & 255 } for (var g = 0; g < 4; g++) { i[g + 4] = l & 255 } var m = ""; for (var g = 0; g < 8; g++) { m += String.fromCharCode(i[g]) } var n = Aes.KeyExpansion(h); var o = Math.ceil(a.length / d); var p = new Array(o); for (var q = 0; q < o; q++) { for (var r = 0; r < 4; r++) { i[15 - r] = q >>> r * 8 & 255 } for (var r = 0; r < 4; r++) { i[15 - r - 4] = q / 4294967296 >>> r * 8 } var s = Aes.Cipher(i, n); var t = q < o - 1 ? d : (a.length - 1) % d + 1; var u = new Array(t); for (var g = 0; g < t; g++) { u[g] = s[g] ^ a.charCodeAt(q * d + g); u[g] = String.fromCharCode(u[g]) } p[q] = u.join("") } var v = m + p.join(""); v = Base64.encode(v); return v }; var Utf8 = {}; Utf8.encode = function (a) { var b = a.replace(/[\u0080-\u07ff]/g, function (a) { var b = a.charCodeAt(0); return String.fromCharCode(192 | b >> 6, 128 | b & 63) }); b = b.replace(/[\u0800-\uffff]/g, function (a) { var b = a.charCodeAt(0); return String.fromCharCode(224 | b >> 12, 128 | b >> 6 & 63, 128 | b & 63) }); return b }; Utf8.decode = function (a) { var b = a.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (a) { var b = (a.charCodeAt(0) & 31) << 6 | a.charCodeAt(1) & 63; return String.fromCharCode(b) }); b = b.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (a) { var b = (a.charCodeAt(0) & 15) << 12 | (a.charCodeAt(1) & 63) << 6 | a.charCodeAt(2) & 63; return String.fromCharCode(b) }); return b }; var Base64 = {}; Base64.code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; Base64.encode = function (a, b) { b = typeof b == "undefined" ? false : b; var c, d, e, f, g, h, i, j, k = [], l = "", m, n, o; var p = Base64.code; n = b ? a.encodeUTF8() : a; m = n.length % 3; if (m > 0) { while (m++ < 3) { l += "="; n += "\0" } } for (m = 0; m < n.length; m += 3) { c = n.charCodeAt(m); d = n.charCodeAt(m + 1); e = n.charCodeAt(m + 2); f = c << 16 | d << 8 | e; g = f >> 18 & 63; h = f >> 12 & 63; i = f >> 6 & 63; j = f & 63; k[m / 3] = p.charAt(g) + p.charAt(h) + p.charAt(i) + p.charAt(j) } o = k.join(""); o = o.slice(0, o.length - l.length) + l; return o }; Base64.decode = function (a, b) { b = typeof b == "undefined" ? false : b; var c, d, e, f, g, h, i, j, k = [], l, m; var n = Base64.code; m = b ? a.decodeUTF8() : a; for (var o = 0; o < m.length; o += 4) { f = n.indexOf(m.charAt(o)); g = n.indexOf(m.charAt(o + 1)); h = n.indexOf(m.charAt(o + 2)); i = n.indexOf(m.charAt(o + 3)); j = f << 18 | g << 12 | h << 6 | i; c = j >>> 16 & 255; d = j >>> 8 & 255; e = j & 255; k[o / 4] = String.fromCharCode(c, d, e); if (i == 64) { k[o / 4] = String.fromCharCode(c, d) } if (h == 64) { k[o / 4] = String.fromCharCode(c) } } l = k.join(""); return b ? l.decodeUTF8() : l }; NullExp.prototype.convert = nNop; NullExp.prototype.revert = nNop; NullExp.prototype.mulTo = nMulTo; NullExp.prototype.sqrTo = nSqrTo; Barrett.prototype.convert = barrettConvert; Barrett.prototype.revert = barrettRevert; Barrett.prototype.reduce = barrettReduce; Barrett.prototype.mulTo = barrettMulTo; Barrett.prototype.sqrTo = barrettSqrTo; var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509]; var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; BigInteger.prototype.chunkSize = bnpChunkSize; BigInteger.prototype.toRadix = bnpToRadix; BigInteger.prototype.fromRadix = bnpFromRadix; BigInteger.prototype.fromNumber = bnpFromNumber; BigInteger.prototype.bitwiseTo = bnpBitwiseTo; BigInteger.prototype.changeBit = bnpChangeBit; BigInteger.prototype.addTo = bnpAddTo; BigInteger.prototype.dMultiply = bnpDMultiply; BigInteger.prototype.dAddOffset = bnpDAddOffset; BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo; BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo; BigInteger.prototype.modInt = bnpModInt; BigInteger.prototype.millerRabin = bnpMillerRabin; BigInteger.prototype.clone = bnClone; BigInteger.prototype.intValue = bnIntValue; BigInteger.prototype.byteValue = bnByteValue; BigInteger.prototype.shortValue = bnShortValue; BigInteger.prototype.signum = bnSigNum; BigInteger.prototype.toByteArray = bnToByteArray; BigInteger.prototype.equals = bnEquals; BigInteger.prototype.min = bnMin; BigInteger.prototype.max = bnMax; BigInteger.prototype.and = bnAnd; BigInteger.prototype.or = bnOr; BigInteger.prototype.xor = bnXor; BigInteger.prototype.andNot = bnAndNot; BigInteger.prototype.not = bnNot; BigInteger.prototype.shiftLeft = bnShiftLeft; BigInteger.prototype.shiftRight = bnShiftRight; BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit; BigInteger.prototype.bitCount = bnBitCount; BigInteger.prototype.testBit = bnTestBit; BigInteger.prototype.setBit = bnSetBit; BigInteger.prototype.clearBit = bnClearBit; BigInteger.prototype.flipBit = bnFlipBit; BigInteger.prototype.add = bnAdd; BigInteger.prototype.subtract = bnSubtract; BigInteger.prototype.multiply = bnMultiply; BigInteger.prototype.divide = bnDivide; BigInteger.prototype.remainder = bnRemainder; BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder; BigInteger.prototype.modPow = bnModPow; BigInteger.prototype.modInverse = bnModInverse; BigInteger.prototype.pow = bnPow; BigInteger.prototype.gcd = bnGCD; BigInteger.prototype.isProbablePrime = bnIsProbablePrime; RSAKey.prototype.doPrivate = RSADoPrivate; RSAKey.prototype.setPrivate = RSASetPrivate; RSAKey.prototype.decrypt = RSADecrypt; var versafe = {}; versafe.EncryptRSA = function (a, b) { try { var c = new RSAKey; c.setPublic(b, "10001"); var d = "[ENC]" + escape(a); var e = ""; var f = ""; for (var g = 0; g < d.length; g += 7) { f = c.encrypt(d.substring(g, g + 7)); if (e != "") { e += "|!|" } e += f } e += "|(!)|"; return e } catch (h) { return a } }; versafe.DecryptRSA = function (a, b, c) { var d = new RSAKey; var e = ""; var f = false; d.setPrivate(b, "10001", c); var g = a.split("|(!)|"); var h = g[0].split("|!|"); for (var i = 0; i < h.length; i++) { var j = d.decrypt(h[i]); if (j != null) { e += j } else { f = true } } if (e.indexOf("[ENC]") != -1 && !f) { return e.substring(5) } else { return null } }; versafe.readCookie = function () { name += "pubKey="; var a = self.document.cookie.split(";"); for (var b = 0; b < a.length; b++) { var c = a[b].replace(/^[ ]*/, ""); if (c.indexOf(name) == 0) return c.substring(name.length, c.length) } return null }
    </script>

    <title></title>
</head>
    <body>
        
        <input type="text" id="publicKey" value="qyw2j3kd">
        <input type="text" id="userNativePassword" value="831da6e605096555f0b55ddd0bf333102c9c2394ad5a80dceff5b87beafc317ea87d68e71e83264dc0a042d815df36ba051ea3cd4eaee9b1f6b38613996e6603">
        <input type="text" id="encryptedPassword">    

    </body>
</html>